---
title: "Dashboards with Shiny for Python"
code-annotations: select
lightbox: auto
aliases: 
  - /docs/dashboards/interactivity/shiny-python.html
---

{{< include /docs/prerelease/1.4/_pre-release-feature.qmd >}}



## Introduction

The [Shiny](https://shiny.posit.co/py/) package provides an easy way to build web applications with Python. Quarto dashboards can include embedded Shiny components (e.g. a plot with sliders that control its inputs).

This section covers integrating Shiny with Quarto and assumes that you already have basic familiarity with Shiny. To learn more about Shiny please visit <https://shiny.posit.co/py/>. If you are using R rather than Python, see the documentation on using [Shiny for R](../shiny-r.qmd).

{{< include _shiny-requirements.qmd >}}

## Hello, Shiny

We'll start with a very simple dashboard that consists of a single plot and some inputs to drive its display:

{{< include _shiny-sidebar.md >}}


## Next Steps

Next, we'll explore a more in-depth example that covers many of the techniques you'll use when creating dashboards with Shiny, including factoring out setup code, reactive calculations, and more advanced layout constructs like pages. Here is the interactive document we'll be building:

![](../../images/penguins-shiny.png){.border fig-alt="Screenshot of a Palmer Penguins dashboard. Navigation bar shows two pages: Plots and Data. On the left is a sidebar with an image of penguins followed by four inputs: a set of checkboxes for Species; a set of checkboxes for Islands; and dropdown for Distribution; and a checkbox to show rug marks. On the right the page is divided into two rows each showing a density plot: the top row of bill_depth_mm; the bottom row of bill_length_mm"}

Here is the source code for this dashboard (click on the numbers on the far right for additional explanation of syntax and mechanics):

```` {.python .pymd}
--- 
title: "Palmer Penguins"
author: "Cobblepot Analytics"
format: dashboard
server: shiny # <1>
---

```{{python}} # <2>
#| context: setup
import seaborn as sns
from shiny import render, reactive, ui
penguins = sns.load_dataset("penguins")
``` # <2>

# {.sidebar} # <3>

![](images/penguins.png){width="80%"}

```{{python}}
species = list(penguins["species"].value_counts().index) # <4>
ui.input_checkbox_group(
    "species", "Species:", 
    species, selected = species
)

islands = list(penguins["island"].value_counts().index)
ui.input_checkbox_group(
    "islands", "Islands:", 
    islands, selected = islands
) # <4>

@reactive.Calc # <5>
def filtered_penguins():
    data = penguins[penguins["species"].isin(input.species())]
    data = data[data["island"].isin(input.islands())]
    return data
``` # <5>

```{{python}}
ui.input_select("dist", "Distribution:", choices=["kde", "hist"]) # <6>
ui.input_checkbox("rug", "Show rug marks", value = False) # <6>
```

[Learn more](https://pypi.org/project/palmerpenguins/) about the 
Palmer Penguins dataset.

# Plots # <7>

```{{python}}
@render.plot
def depth():
    return sns.displot(  # <8>
        filtered_penguins(), x = "bill_depth_mm", 
        hue = "species", kind = input.dist(), 
        fill = True, rug=input.rug()
    ) # <8>
``` 

```{{python}}
@render.plot
def length():
    return sns.displot(
        filtered_penguins(), x = "bill_length_mm", 
        hue = "species", kind = input.dist(), 
        fill = True, rug=input.rug()
    )
``` 

# Data

```{{python}} 
@render.data_frame
def dataview():
    return render.DataGrid(filtered_penguins()) # <9>
``` 
````

1.  The `server: shiny` option instructs Quarto to run a Shiny Server behind the document.

2.  The `context: setup` cell option indicates that this code cell should run when the application starts (as opposed to when each new client session starts). Expensive initialization code (e.g. loading data) should be placed in `context: setup`.

3.  Create global sidebars by adding the `.sidebar` class to a level 1 header. Sidebars can include code cells as well as images, narrative, and links.

4.  These checkbox input groups have their contents dynamically driven from the available categories in the `species` and `islands` fields of the dataset.

5.  When the user interacts with the checkbox groups this results in a different filtered view of the dataset. The `@reactive.Calc` function recomputes the filtered dataset and makes it available as `filtered_penguins()`.

6.  These inputs affect the display of plots but not the contents of the filtered dataset.

7. Level 1 headings (here `# Plots` and `# Data`) create pages within the dashboard.

8.  Plots are rendered by referencing the filtered dataset (`filtered_penguins()` as well as the plot display oriented inputs (`input.dist()` and `input.rug()`). Plots are automatically re-rendered when the dataset or these inputs change.

9. The Data tab also references `filtered_penguins()` and is updated whenever the filtered data changes.

## Learning More

To learn more about Shiny for Python interactive documents see the following articles:

-   [Running Dashboards](running.qmd) covers in more depth how to run Shiny dashboards both within VS Code and at the command line, as well as how to deploy them to end users.

-   [Execution Contexts](execution.qmd) goes in depth on when different code cells run (e.g. rendering vs. serving).

-   [Shiny for Python](https://shiny.posit.co/py/) provides in-depth documentation on all of the available UI and ouput widgets, as well as conceptual discussions on how things work.