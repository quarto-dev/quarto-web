---
title: Four Ways to Dark Notebook
author: Gordon Woodhull
draft: false
demo-site: https://gordonwoodhull.github.io/jupyter-notebook-renderings
---

Quarto 1.7 introduced a new cell option called [renderings](https://quarto.org/docs/computations/execution-options.html#cell-renderings), which allows you to emit both a light and a dark rendering of your plot or table in a code cell, and Quarto will make the light rendering visible in light mode, and the dark rendering visible in dark mode.

I wanted to see how well this feature plays with Jupyter Notebooks rendered in Quarto, to produce HTML versions of notebooks with dark mode enabled. It works great! But there's a big catch that makes this interesting.

This post will be an exploration of how `renderings` works, how a Quarto document and a Jupyter notebook are equivalent for Quarto rendering, and the shortcodes Quarto provides to make it easier to work with Quarto features in a Jupyter notebook.

### The catch

Usually in a Quarto markdown document you will specify cross-references, subfigures and captions as cell options like this:

````
```{{python}}
{{< include polar-axis.py >}}
```
````

```{python}
{{< include polar-axis.py >}}
```

These are equivalent to code cells in a Jupyter notebook, and normally you would put the same options at the top of the cell:

![jupyter cell](jupyter-cell-light.png){.light-content}
![jupyter cell](jupyter-cell-dark.png){.dark-content}


However, none of the cross-reference or caption cell options are compatible with `renderings`! Instead, in a Quarto markdown document you need to use the fenced div syntax to add cross-references and captions:

````
::: {#fig-polar-axis-light-dark}

```{{python}}
{{< include polar-axis-renderings.py >}}
```

Polar axis plot with light and dark renderings.

:::
````

::: {#fig-polar-axis-light-dark}

```{python}
{{< include polar-axis-renderings.py >}}
```

Polar axis plot with light and dark renderings.

:::

But how do we do this in a Jupyter notebook? As we'll see, there are two low-level ways and two high-level ways. This blog post will describe the ways from the lowest to highest level:

0. Image tags with hard-coded paths and light & dark classes (a level below cell `renderings`)
1. Fenced divs in Jupyter markdown cells around light & dark cell renderings
2. Light and dark renderings placed in fenced divs in Jupyter markdown cells
3. Light and dark renderings embedded in fenced divs in Jupyter markdown cells

If you only want to see the simplest way to get light and dark notebook output from your Jupyter notebook in Quarto, feel free to skip to [Way 2](#way-2).

If you want to learn how to add static light and dark images to your Quarto document, continue to Way 0 below.

If you want to learn the lowest-level way to combine Quarto's fenced divs with Jupyter code cells, continue to [Way 1](#way-1).

## Way 0: Image tags with hard-coded paths and light & dark classes {#way-0}

This is a brief digression from `renderings` to the technologies underpinning it: Markdown and CSS.

Say you want to display different versions of a static image in light mode or dark mode. 

*why does this move up and down slightly? i've tried removing line breaks, using fenced divs, spans...*

````
![an elephant](elephant.png){.light-content}
![an elephant](elephant-dark.png){.dark-content}
````

::: {.light-content}
![an elephant](elephant.png)
:::
::: {.dark-content}
![an elephant](elephant-dark.png)
:::

Quarto has CSS rules to hide anything with the CSS class `.light-content` when in dark mode, and everything with `.dark-content` when in light mode.

And you could write Markdown that displays your computed output this way: have a notebook that produces image files with known filenames as a side effect, and use those filenames in image tags in your Markdown. 

This would work, but you would have to remember to run the other notebook first. In time, you'd have to document what order to run the notebooks and what artifacts are produced by which notebook, or you'd have to trust your memory. 

As a shorthand, we at Quarto say "that's not reproducible". It doesn't mean that you couldn't reproduce it, but it means there is nothing in the system that ensures the computed images are up to date, or even that they were produced by the right code.

For the rest of this blog post, we'll get back to executable cells producing light and dark plot and table output, and we'll use the `renderings` feature, which turns computed outputs into HTML similar to the Markdown above.

## Way 1: Fenced divs in Jupyter markdown cells around light & dark cell renderings {#way-1}

Here we'll go into how Quarto documents and Jupyter notebooks are equivalent for rendering in Quarto, and a very direct but low-level way to combine `renderings` with cross-references and captions.

If you want to see a simple way to enable cross-reference and captions with the `renderings` cell option, skip to [Way 2](#way-2).

Quarto documents and Jupyter notebooks are isomorphic: you can transform a Quarto document into an equivalent Jupyter notebook, and vice-versa. The one exception is that Jupyter notebooks contain computational results, and Quarto documents do not.

If you `quarto convert` a Quarto document into a Jupyter notebook, code blocks turn into Jupyter code cells, and the rest of the Markdown turns into Markdown cells around and between the code cells. Likewise if you `quarto convert` a Jupyter notebook to a Quarto document, the Jupyter code cells become Quarto code blocks, and Markdown cells become the body of the Quarto Markdown document, around the code blocks.

When Quarto renders a Jupyter notebook, it's not converted to a Quarto document, but it produces an intermediate Pandoc markdown document with all of the computational results included. This Pandoc markdown document observes the same transformations described above.

So we can build our fenced divs around the code cells, as shown in the [matplotlib markdown example]({{< meta demo-site >}}/matplotlib-markdown.html).

::: {.callout-tip}
## Jupyter raw cells

In all the example notebooks for this blog post, I'm using Jupyter's Raw cells instead of Markdown cells. These have the same effect as Markdown cells, except that when they are rendered in the notebook interface, the raw text will be displayed instead of trying to render it. 

I find it more helpful to see the raw Quarto markdown, since we're building structure around the code cells.  Although the jupyterlab-quarto extension and the Quarto extension for VSCode improve the rendering of Quarto-specific markdown, 

If you `quarto convert` a Quarto document to a Jupyter notebook, it will use Markdown cells, not raw cells. 
:::


## Way 2: Light and dark renderings placed in fenced divs in Jupyter markdown cells via the `contents` shortcode{#way-2}


## Way 3: Light and dark renderings embedded in fenced divs in Jupyter markdown cells via the `embed` shortcode {#way-3}