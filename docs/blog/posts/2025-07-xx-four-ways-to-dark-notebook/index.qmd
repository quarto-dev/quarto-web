---
title: Four Ways to Dark Notebook
author: Gordon Woodhull
draft: false
demo-site: https://gordonwoodhull.github.io/jupyter-notebook-renderings
reference-location: margin
---

### Introduction

Quarto 1.7 introduced a new cell option called [renderings](https://quarto.org/docs/computations/execution-options.html#cell-renderings), which allows you to emit both a light and a dark rendering of your plot or table in a code cell. Quarto will make the light rendering visible in light mode, and the dark rendering visible in dark mode.

I wanted to see how well this feature plays with Jupyter Notebooks rendered in Quarto, to produce HTML versions of notebooks with dark mode enabled. It works great! But there's a big catch that makes this interesting.

This post will be an exploration of how `renderings` works, how a Quarto document and a Jupyter notebook are equivalent for Quarto rendering, and how to use shortcodes to more easily work with Quarto features in a Jupyter notebook.

### The catch

Usually in a Quarto markdown document you will specify cross-references, subfigures and captions as cell options like this:

````
```{{python}}
{{< include polar-axis.py >}}
```
````

```{python}
{{< include polar-axis.py >}}
```

These are equivalent to code cells in a Jupyter notebook, and normally you would put the same options at the top of the cell. Here's a screenshot using the VSCode Jupyter extension in Positron:

![jupyter cell](jupyter-cell-light.png){.light-content}
![jupyter cell](jupyter-cell-dark.png){.dark-content}


However, none of the cross-reference or caption cell options are compatible with `renderings`! Instead, in a Quarto markdown document you need to put fenced divs around the code blocks to add cross-references and captions:

````
::: {#fig-polar-axis-light-dark}

```{{python}}
{{< include polar-axis-renderings.py >}}
```

Polar axis plot with light and dark renderings.

:::
````

::: {#fig-polar-axis-light-dark}

```{python}
{{< include polar-axis-renderings.py >}}
```

Polar axis plot with light and dark renderings.

:::

But how do we do this in a Jupyter notebook? And what does it mean to add markdown "around" a Jupyter code cell?

As we'll see, there are two low-level ways and two high-level ways. This blog post will describe the ways from the lowest to highest level:

0. Image tags with hard-coded paths and light & dark classes (a level below cell `renderings`)
1. Fenced divs in Jupyter markdown cells around light & dark cell renderings
2. Light and dark renderings placed in fenced divs in Jupyter markdown cells via the `contents` shortcode
3. Light and dark renderings embedded in fenced divs in Jupyter markdown cells via the `embed` shortcode

If you only want to see the simplest way to get light and dark notebook output from your Jupyter notebook in Quarto, feel free to skip to [Way 2](#way-2).

If you want to learn how to add static light and dark images to your Quarto document, continue to Way 0 below.

If you want to learn the lowest-level way to combine Quarto's fenced divs with Jupyter code cells, continue to [Way 1](#way-1).

## Way 0: Image tags with hard-coded paths and light & dark classes {#way-0}

This Way is a brief digression from `renderings` to the technologies underpinning it: Markdown and CSS.

Say you want to display different versions of a static image in light mode or dark mode. 

*Why is this code block slightly taller in dark mode? The elephant is okay on its own!*

````
![an elephant](elephant.png){.light-content}
![an elephant](elephant-dark.png){.dark-content}
````

![an elephant](elephant.png){.light-content}
![an elephant](elephant-dark.png){.dark-content}

Quarto has CSS rules to hide anything with the CSS class `.light-content` when in dark mode, and everything with `.dark-content` when in light mode.

And you could write Markdown that displays your computed output this way: have a notebook that produces image files with known filenames as a side effect, and use those filenames in image tags in your Markdown. 

This would work, but you would have to remember to run the other notebook first. In time, you'd have to document what order to run the notebooks and what artifacts are produced by which notebook, or you'd have to trust your memory. 

As a shorthand, we at Quarto say "that's not reproducible". It doesn't mean that you couldn't reproduce it, but it means there is nothing in the system that ensures the computed images are up to date, or even that they were produced by the right code.

For the rest of this blog post, we'll get back to executable cells producing light and dark plot and table output, and we'll use the `renderings` feature, which turns computed outputs into HTML similar to the Markdown above.

## Way 1: Fenced divs in Jupyter markdown cells around light & dark cell renderings {#way-1}

Here we'll go into how Quarto documents and Jupyter notebooks are equivalent for rendering in Quarto, and a very direct but low-level way to combine `renderings` with cross-references and captions.

It's not a pretty or an easy way, but it's instructive and you might use it for a quick fix if you aren't sharing your notebook with people who won't understand it. 

If you want an easy way to enable cross-reference and captions with the `renderings` cell option, skip to the `contents` shortcode in [Way 2](#way-2).

### Isomorphism of qmd and ipynb

Quarto documents and Jupyter notebooks are isomorphic: you can transform a Quarto document into an equivalent Jupyter notebook, and vice-versa. The one main exception is that Jupyter notebooks contain computational results, and Quarto documents do not.

If you `quarto convert` a Quarto document into a Jupyter notebook, code blocks turn into Jupyter code cells, and the rest of the Markdown turns into Markdown cells around and between the code cells. Likewise if you `quarto convert` a Jupyter notebook to a Quarto document, the Jupyter code cells become Quarto code blocks, and Markdown cells become the body of the Quarto Markdown document, around the code blocks.

When Quarto renders a Jupyter notebook, it's not converted to a Quarto document, but it produces an intermediate Pandoc markdown document with all of the computational results included. This Pandoc markdown document observes the same transformations: the Jupyter code cells become Pandoc code blocks, this time with results, and the Markdown cells become the body of the Pandoc markdown, around the code blocks and results.

Returning to our first example, we can add a cross-reference by building a fenced div with caption in two markdown cells around the code cell:

![matplotlib with markdown fenced div](matplotlib-markdown-light.png){.light-content}
![matplotlib with markdown fenced div](matplotlib-markdown-dark.png){.dark-content}

You can see this example live at [matplotlib markdown example]({{< meta demo-site >}}/matplotlib-markdown.html). 

Now let's dive into a Plotnine Gapminder example, which we'll use for the rest of the post. We'll display the Gapminder 1957 and Gapminder 2007 plots as subfigures with both light and dark renderings.

![fenced divs in Jupyter raw cells](raw-cell-subfigures-light.png){.light-content}
![fenced divs in Jupyter raw cells](raw-cell-subfigures-dark.png){.dark-content}

You can see this example live, along with the rest of the code, at [plotnine markdown example]({{< meta demo-site >}}/plotnine-markdown.html). 

The notebook uses theme helper functions from the main branch of the [quarto-python](https://github.com/quarto-dev/quarto-python) package, to be released later this year.

Here we build two levels of fenced divs in order to combine the plots in a figure with the subfigures in two columns, with cross-references for each of the subfigures as well as the parent figure.

We start by opening two fenced divs in a raw cell, `#fig-gapminder` and `#fig-gapminder-1957`, figure and subfigure.

Then a code cell with `renderings: [light, dark]` outputs the 1957 plot in light and dark themes.

The `gapminder_plot(year)` function, not shown here, takes the year and data provided in the notebook to display the bubble plot with Plotnine.

Then another raw cell adds the caption for the 1957 plot, closes the subfigure, and opens the `#fig-gapminder-2007` subfigure.

Then a code cell outputs the 2007 plot in light and dark themes.

And a final raw cell adds captions and closes the subfigure and figure fenced divs.

Phew! If you've read this far and think this is great, please go forth and use this. It totally works, and it's neat that Jupyter notebooks are isomorphic to Quarto notebooks.

However, we generally don't recommend this. Even if you get it, it's going to be confusing to your colleagues and coworkers. We present it here to show how Jupyter notebooks are deeply equivalent to Quarto markdown documents.

So let's look at the `contents` shortcode, the nice way to build fenced divs around your results in a Jupyter notebook.

::: {.callout-tip}
## Jupyter raw cells

In the example notebooks for this blog post, I'm using Jupyter's Raw cells instead of Markdown cells. These have the same effect as Markdown cells, except that when they are rendered in the notebook interface, the raw Quarto markdown will be displayed instead of an HTML representation. 

I find it more helpful to see the Quarto markdown, since we're building structure around the code cells.  Although the jupyterlab-quarto extension and the Quarto extension for VSCode improve the rendering of Quarto-specific markdown, I prefer to see the code rather than a rendering of half a fenced div.

If you `quarto convert` a Quarto document to a Jupyter notebook, it will use Markdown cells, not raw cells. So this is something that doesn't round-trip from a Jupyter notebook to a Quarto document and back.
:::

## Way 2: Light and dark renderings placed in fenced divs in Jupyter markdown cells via the `contents` shortcode{#way-2}

We don't have to build our prose around our code, and beyond exploratory notebooks, we probably shouldn't.

It's better to consolidate our Markdown in one cell or a few cells of our notebook, and then display the results from computational cells in the Markdown using the `contents` shortcode. 

It causes the output of a code cell (or any cell) from the same notebook to be removed from its original location and placed at the location of the shortcode.

Here's how we implement the Gapminder subfigure example using the `contents` shortcode:

![contents shortcode](contents-shortcode-light){.light-content}
![contents shortcode](contents-shortcode-dark){.dark-content}

It's finding the outputs by their identifiers of the code cells `#gapminder-1957`, `#gapminder-2007`. 

Notice this is not a cross-reference identifier because it does not start with `#fig-`, `#tbl-`, or any of the prefixes that cause a cross-reference.

One of the cells:

![contents source cell](contents-source-cell-light){.light-content}
![contents source cell](contents-source-cell-dark){.dark-content}

::: {.callout-tip}

## `label` has multiple purposes

* to provide an identifier that can be used with the `contents` shortcode (or `embed` shortcode, as we'll see).
* to create an HTML fragment identifer that can be linked to with `#id`.  
* to provide a base for output filenames, so that artifacts like plot images have readable filenames instead of just numbers.
* to create a cross-reference if one of the reserved prefixes is used. ([docs](https://quarto.org/docs/authoring/cross-references.html))
:::


### Digression on narrative flow

The `contents` shortcode is interesting because it changes the way time, or at least narrative, works in a notebook. 

We still have the linear execution timeline of code cells. 

But now the prose does not have to follow the same order as the code. 

The composition of the output in Quarto and Pandoc happens after all the code has executed, and you can refer to results from anywhere in the notebook. (In fact, by default when Quarto renders a Jupyter notebook, it assumes that all the cells have been run and the output saved. So there is no execution, only rendering.)

Of course, the `contents` shortcode also works in Quarto markdown, allowing the same consolidation of prose and reordering of output.

Literate Programming always has the problem of two stories being told at the same time: the prose and the code.

We don't necessarily want to explain the code in the same order that it needs to run, and we'll often lose our readers if we try to explain all the code.

But all the code should be there, with the prose.

::: {.callout-note}

# Quarto doesn't execute Jupyter notebooks?

By default, Quarto does not run Jupyter cells when rendering a Jupyter notebook.

After all, you're still running your notebook in Jupyter, so you probably don't want us also running your code when we render. Just save the results in the notebook, and we'll pick them up.

You can use `quarto render --execute` if you want to run the code in Quarto instead, and you need to run your notebook that way if you are using [inline code](https://quarto.org/docs/computations/inline-code.html).

:::

## Way 3: Light and dark renderings embedded in fenced divs in Jupyter markdown cells via the `embed` shortcode {#way-3}

To completely separate the prose from the code while retaining reproducibility, use the `embed` shortcode, which includes content from another Jupyter notebook or Quarto document.

The `embed` shortcode causes the other notebook or document to be rendered separately and given its own page in your website. It inserts the embedded content and a link to the notebook, and it also causes a link to the notebook to be put at the top of the page.

Now our prose narrative is 